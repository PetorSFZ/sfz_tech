// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license(the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third - parties to whom the Software is furnished to
// do so, all subject to the following :
//
// The copyright notices in the Softwareand this entire statement, including
// the above license grant, this restrictionand the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine - executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON - INFRINGEMENT.IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

#pragma once

#include <visit_struct/visit_struct.hpp>

// About
// ------------------------------------------------------------------------------------------------

// This is a copy of the reference implementation of "is_fully_visitable()" from the visit_struct
// library. It is included in a sample, and not in the library itself. It's still under copyright
// and licensed under the same license as visit_struct of course.

// "is_fully_visitable" extension from "visit_struct/test_fully_visitable.cpp"
// ------------------------------------------------------------------------------------------------

// Code in `namespace ext` implements a type trait, "is_fully_visitable".
//
// This is a compile-time test which attempts to verify that a visitable structure
// has all of its fields registered.
//
// It does this by checking the sizeof the structure vs what the size should be
// if the visitable fields are all of the fields.
//
// This is an illustration of how visit_struct can be used to do
// some nontrivial compile-time metaprogramming.
//
// (Old versions required C++14, for constexpr visitation, but using
//  visit_struct::type_at, we can now do it with only C++11.)
//
// Potentially, you could use it to catch bugs at compile-time which occur
// if e.g. a member is added to a struct but the programmer forgets to add it
// to the VISITABLE_STRUCT macro also.
//
// Tested against gcc 4.8, 4.9, 5.4, 6.2 and clang 3.5, 3.8

namespace ext {

// C++11 replacement for std::index_sequence
template <std::size_t ...>
struct seq {};

// Concatenate sequences
template <class, class>
struct cat_s;

template <std::size_t ... as, std::size_t ... bs>
struct cat_s<seq<as...>, seq<bs...>> {
	using type = seq<as..., bs...>;
};

template <class s1, class s2>
using cat = typename cat_s<s1, s2>::type;

// Count

template <std::size_t s>
struct count_s {
	using type = cat<typename count_s<s-1>::type, seq<s-1>>;
};

template <>
struct count_s<0> {
	using type = seq<>;
};

template <std::size_t s>
using count = typename count_s<s>::type;

// It turns out it is implementation-defined whether `std::tuple` lists its members
// in order specified or in reverse order, and some standard libraries do it differently.
// So we have to make it up a bit here for our intended application, and we don't need
// full tuple interface anyways, we only need the size to be correct.
// This is based on libc++ implementation.

// Note: Extra std::size_t parameter is here to avoid "duplicate base type is invalid" error
template <typename T, std::size_t>
struct mock_tuple_leaf { T t; };

template <typename I, typename ... Ts>
struct mock_tuple;

template <typename ... Ts, std::size_t ... Is>
struct mock_tuple<seq<Is...>, Ts...> : mock_tuple_leaf<Ts, Is> ... {};

template <typename ... Ts>
using mock_tuple_t = mock_tuple<count<sizeof...(Ts)>, Ts...>;

// Build mock from a visitable structure
// Does the work

template <typename T>
struct mock_maker {
	template <typename is>
	struct helper;

	template <std::size_t ... Is>
	struct helper<seq< Is...>> {
		using type = mock_tuple_t<visit_struct::type_at<Is, T> ...>;
	};

	using type = typename helper<count<visit_struct::field_count<T>()>>::type;
	static constexpr std::size_t size = sizeof(type);
};


} // end namespace ext

// Final result

namespace visit_struct {

template <typename T>
constexpr bool is_fully_visitable() {
	return sizeof(T) == ext::mock_maker<T>::size;
}

} // namespace visit_struct
